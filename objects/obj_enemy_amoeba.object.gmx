<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>msk_enemy_amoeba</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>par_enemy</parentName>
  <maskName>msk_enemy_amoeba</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialise variables
max_hp = 100
hp = 100
hit = false
can_hit = true
hp_alpha = 1

// get shader constant handle
colour_to_find = shader_get_uniform(shader_hit_flash, "f_Colour1");



//hspeed = 3
//alarm[3] = 120

target_position_x = random_range(100, room_width-100);
target_position_y = random_range(600, room_height-300);
alarm[4] = 4*room_speed;
alarm[5] = 8;

targeting_player = false;
rotate_clockwise = false;
reverse_time = random_range(room_speed, room_speed*10);
alarm[6] = reverse_time;
rotate_divisor = 128;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Generate outline
    waterdiameter = 376
    //waterheight = room_height - y;
    waterradius = 32
    if (global.lower_performance) {
      nodewidth = 32;
      nodes = floor(waterdiameter/nodewidth)+3;
    }
    else {
      nodewidth = 8; //as this is lowered the water waves will get thinner but more precise, and more of them
      nodes = floor(waterdiameter/nodewidth)+1;
    }

    //physics variables
    spring = 6; //higher numbers will make the liquid act thicker
    fricdiv = 2; //higher numbers will be less dynamic
    
    //individual nodes
    for (i = 0; i &lt; nodes; i += 1)
    {
        xx[i] = x+random_range(-5,5);
        xsp[i] = 0; 
        yy[i] = y+random_range(-5,5);;
        ysp[i] = 0;
        frc[i] = (ysp[i])/(room_speed/fricdiv);
    }
    

move = 0
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialise bullet pattern

//bhpg_pattern_init(1,90,65,1,40,90,0,1,90,50,1,1,0,0);
//bhpg_pattern_init(2,90,65,1,90,90,0,2,90,75,1,1,0,0);
bhpg_pattern_init(1,65,135,1,90,90,-0.25,0,30,8/*4*/,1,1,0,0);

bhpg_bullet_init(obj_bullet_enemy,3,0.05,0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>rotate_clockwise = !rotate_clockwise;
alarm[6] = reverse_time;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Wiggle code

for (i = 0; i &lt; nodes; i += 1)
{
  //movement
  xsp[i] += random_range(-0.2, 0.2);
  ysp[i] += random_range(-0.2, 0.2);       
}

alarm[5] = 8;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Change target destination
target_position_x = random_range(100, room_width-100);
target_position_y = random_range(600, room_height-300);
alarm[4] = 4*room_speed;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//hspeed = hspeed*-1
//alarm[3] = 120
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DO NOT USE!!! Used as shooting timer
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_hit = true
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hit = false
alarm[1] = 2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()

if hp &lt; 1
{
 instance_destroy()
 instance_create(x,y,obj_explode64)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement Code

if (instance_number(obj_ship) &gt; 0) {
  targeting_player = (distance_to_object(obj_ship) &lt; 256);
}

if (targeting_player) {
  if (instance_number(obj_ship) &gt; 0) {
    bhpg_pattern_step();
    dist_to_player = distance_to_object(obj_ship);
    angle_to_player = point_direction(x, y, obj_ship.x, obj_ship.y);
    start_angle = angle_to_player;
    if (rotate_clockwise) {
      hspeed = lengthdir_x(dist_to_player, angle_to_player-90)/rotate_divisor;
      vspeed = lengthdir_y(dist_to_player, angle_to_player-90)/rotate_divisor;
    }
    else {
       hspeed = lengthdir_x(dist_to_player, angle_to_player+90)/rotate_divisor;
       vspeed = lengthdir_y(dist_to_player, angle_to_player+90)/rotate_divisor;
    }
  }
}
else {
  move_towards_point(target_position_x, target_position_y, 0.5);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Outline

    var drop; 
    for (i = 0; i &lt; nodes; i += 1)
    {
        //if ((i-1 &gt; -1) &amp;&amp; (i+1 &lt; nodes))
        {
            
            node_prev_index = (i+nodes-1)%nodes;
            node_after_index = (i+nodes+1)%nodes;
            
            xsp[i] += ((((xx[node_prev_index]-xx[i])+(xx[node_after_index]-xx[i]))+(xsp[node_prev_index]+xsp[node_after_index])))/(room_speed*spring);
            xsp[i] += (x-xx[i])/(room_speed*spring);
            frc[i] = (xsp[i])/(room_speed/fricdiv);
            xsp[i] -= frc[i];
            
            ysp[i] += ((((yy[node_prev_index]-yy[i])+(yy[node_after_index]-yy[i]))+(ysp[node_prev_index]+ysp[node_after_index])))/(room_speed*spring);
            ysp[i] += (y-yy[i])/(room_speed*spring);
            frc[i] = (ysp[i])/(room_speed/fricdiv);
            ysp[i] -= frc[i];
            
            //collision
            drop = collision_circle(lengthdir_x(waterradius, i*nodewidth)+xx[i], lengthdir_y(waterradius, i*nodewidth)+yy[i], nodewidth/2, obj_physics, 0, 1);
            if (drop)
            {
                if (abs(drop.xsp) &gt; 0.5)
                {
                    xsp[i] = divide(drop.xsp/4, max(1, point_distance(drop.x, y, x+lengthdir_x(waterradius, i*nodewidth), y)/16));
                }
                
                if (abs(drop.ysp) &gt; 0.5)
                {
                    ysp[i] = divide(drop.ysp/4, max(1, point_distance(x, drop.y, x, y+lengthdir_y(waterradius, i*nodewidth))/16));
                }

            }

            //actually move the node
            //if !(collision_circle(x+(i*nodewidth), yy[i], nodewidth/2, obj_wavecreate, 0, 1) &amp;&amp; ((ysp[i] &gt; 2 &amp;&amp; (yy[i] &lt; -4 || yy[i] &gt; 4)) || (ysp[i] &lt; -2 &amp;&amp; (yy[i] &gt; 4 || yy[i] &lt; -4)))) 
            //{
             xx[i] += xsp[i]
             yy[i] += ysp[i];
            //}
            
        }
    }
    


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update Physics
update_physics();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_bullet">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if hit = false &amp;&amp; hp &gt; 0 &amp;&amp; can_hit = true
{
 hit = true
 alarm[0] = 2
 can_hit = false
 hp -= 2
 alarm[2] = room_speed*2
}

with (other)
{
 instance_destroy()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw outline
if (instance_number(obj_ship) &gt; 0 &amp;&amp; point_distance(x,y,obj_ship.x, obj_ship.y) &lt; 1200) {

        //draw the water's body
    //draw_set_color(18577);
    draw_set_colour(make_colour_rgb(0,30,30))
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
    draw_primitive_begin(pr_trianglestrip);
    
    for (i = 0; i &lt; nodes; i += 1)
    {
   // gradient += 2
    //draw_set_color(18577+( sin(degtorad(gradient))*50 ) );
        draw_vertex(xx[i]+lengthdir_x(waterradius, i*nodewidth), yy[i]+lengthdir_y(waterradius, i*nodewidth));
        draw_vertex(x, y);
        //draw_line_width(x+(i*nodewidth),y+399,x+(i*nodewidth),room_height,nodewidth)
    }
    //draw_rectangle(x,y+400,x+waterwidth,room_height,false)
    
    draw_primitive_end();

    
    draw_set_alpha(1);
    draw_set_blend_mode(bm_normal);
    draw_set_color(c_white);
    
    //draw the water's surface
    /*
    var pth, wid, stp, stp_i, xt, xt_i, sgn, a, a_i, x1, y1, x2, y2, i, px, py, nx, ny, vert_count;
    
    wid = 4; //half the width of water surface
    
    px = x;
    py = yy[0];
    
    vert_count = 0;
    draw_primitive_begin_texture(pr_trianglestrip, sprite_get_texture(sprWaterTop, 0));
    
    for (i = 0; i &lt; nodes; i += 1) 
    {

        nx = x+(i*nodewidth);
        ny = yy[i];

        dir = point_direction(px, py, nx, ny);
        dx = lengthdir_x(wid, dir+90);
        dy = lengthdir_y(wid, dir+90);

        xt = (i-1)/nodes;
        draw_vertex_texture(px+dx, py+dy, xt, 0);
        draw_vertex_texture(px-dx, py-dy, xt, 1);
        px = nx;
        py = ny;
    }
    
    draw_vertex_texture(px+dx, py+dy, xt, 0);
    draw_vertex_texture(px-dx, py-dy, xt, 1);
    draw_primitive_end();
    */
  draw_set_color(c_black)

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw healthbar
if (instance_number(obj_ship) &gt; 0 &amp;&amp; point_distance(x,y,obj_ship.x, obj_ship.y) &lt; 1200) {


  if hp &lt; max_hp
  {
  if alarm[2] &gt; -1
   {
    if hp_alpha &lt; 1
    {
     hp_alpha += 0.1
    }
    draw_set_alpha(hp_alpha)
    draw_healthbar(x-(sprite_width/2)-4, y-(sprite_height/2)-12, x+(sprite_width/2)+4, y-(sprite_height/2)-8,(hp/max_hp)*100, make_color_rgb(255,65,40),c_lime, c_green, 0, true, false)
    draw_set_alpha(1);
   }
   else
   {
    if hp_alpha &gt; 0.4
    {
     hp_alpha -= 0.05
    }
    draw_set_alpha(hp_alpha)
    draw_healthbar(x-(sprite_width/2)-4, y-(sprite_height/2)-12, x+(sprite_width/2)+4, y-(sprite_height/2)-8,(hp/max_hp)*100, make_color_rgb(255,65,40),c_lime, c_green, 0, true, false) 
    draw_set_alpha(1)
    
   }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>-1</PhysicsObject>
  <PhysicsObjectSensor>-1</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>32,32</point>
    <point>24,16</point>
  </PhysicsShapePoints>
</object>
